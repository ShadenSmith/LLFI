#! /usr/bin/env python3

"""
llfi-profile takes a profiling executable and executes it

Prerequisites:
  1. 'input.yaml' contains appropriate options for LLFI and must be in the
     current working directory.
  2. You need to be in the parent directory of the PROF_EXE to invoke
     llfi-profile. This is to make it easier for LLFI to track the outputs
     generated by PROF_EXE.
  3. llfi-profile only checks recursively in the current directory for possible
     outputs. If your output is not under current directory, you need to store
     that output by yourself.
  4. You need to put input files (if any) in the current working directory.
"""

# This script profiles the program to produce llfi.stat.prof.txt

import sys
import yaml
import os
import time
import subprocess
import shutil
import argparse

prog = os.path.basename(sys.argv[0])

basedir = os.getcwd()

def usage(msg = None):
  retval = 0
  if msg is not None:
    retval = 1
    msg = "ERROR: " + msg
    print(msg, file=sys.stderr)
  print(__doc__ % globals(), file=sys.stderr)
  sys.exit(retval)

def help():
  parser = initParser()
  parser.print_help()

def initParser():
  parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    prog='llfi profile',
    epilog=__doc__,
  )
  parser.add_argument('PROF_EXE', help='instrumented executable')
  parser.add_argument('EXE_ARGS', nargs='*',
                      help='arguments to PROF_EXE used during profiling')
  return parser

def parseArgs(parser, args):
  options = parser.parse_args(args)
  options.PROF_EXE = os.path.realpath(options.PROF_EXE)
  if os.path.dirname(os.path.dirname(options.PROF_EXE)) != basedir:
    usage("You need to invoke llfi-inject at the parent directory of PROF_EXE")

  # remove the directory prefix for input files, this is to make it easier for the program
  # to take a snapshot
  for index, opt in enumerate(options.EXE_ARGS):
    if os.path.isfile(opt):
      if os.path.realpath(os.path.dirname(opt)) != basedir:
        usage("File %s passed through option is not under current directory" % opt)
      else:
        options.EXE_ARGS[index] = os.path.basename(opt)

  return options

def checkInputYaml(prof_exe):
  #Check for input.yaml's presence
  yamldir = os.path.dirname(os.path.dirname(prof_exe))
  try:
    f = open(os.path.join(yamldir, 'input.yaml'), 'r')
  except:
    usage("No input.yaml file in the parent directory of profiling executable")
    exit(1)

  #Check for input.yaml's correct formmating
  try:
    doc = yaml.load(f)
    f.close()
  except:
    usage("input.yaml is not formatted in proper YAML (reminder: use spaces, not tabs)")
    exit(1)


################################################################################
def config(profiling_exe):
  global inputdir, outputdir, baselinedir, errordir
  # config
  llfi_dir = os.path.dirname(profiling_exe)

  inputdir = os.path.join(llfi_dir, "prog_input")
  outputdir = os.path.join(llfi_dir, "prog_output")
  baselinedir = os.path.join(llfi_dir, "baseline")
  errordir = os.path.join(llfi_dir, "error_output")

  if not os.path.isdir(outputdir):
    os.mkdir(outputdir)
  if not os.path.isdir(baselinedir):
    os.mkdir(baselinedir)
  if not os.path.isdir(errordir):
    os.mkdir(errordir)
  if not os.path.isdir(inputdir):
    os.mkdir(inputdir)

################################################################################
def execute(execlist):
  global outputfile
  print('\t' + ' '.join(execlist))
  #get state of directory
  dirSnapshot()
  p = subprocess.Popen(execlist, stdout = subprocess.PIPE)
  elapsetime = 0
  while True:
    elapsetime += 1
    time.sleep(1)
    #print p.poll()
    if p.poll() is not None:
      moveOutput()
      print("\t program finish", p.returncode)
      print("\t time taken", elapsetime,"\n")
      outputFile = open(outputfile, "wb")
      outputFile.write(p.communicate()[0])
      outputFile.close()
      replenishInput() #for cases where program deletes input or alters them each run
      #inputFile.close()
      return p.returncode

################################################################################
def storeInputFiles(exe_args):
  global inputList
  inputList=[]
  for opt in exe_args:
    if os.path.isfile(opt):#stores all files in inputList and copy over to inputdir
      shutil.copy2(opt, os.path.join(inputdir, opt))
      inputList.append(opt)

################################################################################
def replenishInput():#TODO make condition to skip this if input is present
  for each in inputList:
    if not os.path.isfile(each):#copy deleted inputfiles back to basedir
      shutil.copy2(os.path.join(inputdir, each), each)

################################################################################
def moveOutput():
  #move all newly created files that are not "llfi.stat.prof.txt" < -- since this is a product of profiling
  newfiles = [_file for _file in os.listdir(".")]
  for each in newfiles:
    if each not in dirBefore and each != "llfi.stat.prof.txt":
      fileSize = os.stat(each).st_size
      if fileSize == 0 and each.startswith("llfi"):
        #empty library output, can delete
        print(each + " is going to be deleted for having size of " + str(fileSize))
        os.remove(each)
      else:
        flds = each.split(".")
        newName = '.'.join(flds[0:-1])
        newName+='.prof.'+flds[-1]
        os.rename(each, os.path.join(baselinedir, newName))

################################################################################
def dirSnapshot():
  #snapshot of directory before each execute() is performed
  global dirBefore
  dirBefore = [_file for _file in os.listdir(".")]

################################################################################
def run(args):
  global outputfile

  parser = initParser()
  options = parseArgs(parser, args)

  checkInputYaml(options.PROF_EXE)
  config(options.PROF_EXE)

  storeInputFiles(options.EXE_ARGS)
  # baseline
  outputfile = os.path.join(baselinedir, "golden_std_output")
  execlist = [options.PROF_EXE]
  execlist.extend(options.EXE_ARGS)

  return execute(execlist)


################################################################################

if __name__=="__main__":
  if len(sys.argv) == 1:
    help()
    exit(1)
  exit(run(sys.argv[1:]))
